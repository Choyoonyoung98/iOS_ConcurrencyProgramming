## 1. 왜 동시성 프로그래밍이 필요할까?
### 1-1. 왜 용량이 높은 이미지 리스트가 버벅일까?
> 아이폰11에서 이미지 리스트를 동작했다고 생각해보자, 아이폰11은 6코어를 가지고 있는 기기이고, 그 뜻은 최소 12개의 스레드(실제로 일하는 녀석들)가 존재하는 것을 의미한다.  
1) 스레드(일하는 녀석)가 여러 개 있음에도 불구하고 하나의 스레드에게 해당 일을 전부 맡겼을 뿐만 아니라,
2) 심지어 그 스레드가 화면을 관리하는 스레드(메인 스레드)이기 때문에 버벅임이 발생하는 것!

### 1-2. 이미지 리스트를 동작하는 일에 부하가 걸리는 이유?
1) 압축 파일을 다운로드
2) 압축을 풀고
3) 이미지파일을 변형(블러처리)
4) 셀에 이미지 표시

그렇다면 하나의 스레드에 집중되어 있는 작업을 "어떻게 분산시킬 수 있을까?: **비동기 프로그래밍**   
iOS에서는 비동기프로그래밍 작업을 **"대기행렬(큐) - FIFO**  에 보내기만 하면 알아서 쓰레드를 찾아서 일을 분산시킨다!

### 1-3. 비동기 프로그래밍을 사용하기 위해 개발자가 해야할 일?
작업을 대기행렬(큐)에 잘 담아보내는 일 

<hr/>

## 2. 간단한 GCD/Operation 소개
- GCD/Operation은 직접적으로 쓰레드를 관리하지 않고, **큐(대기열/대기행렬)** 라는 개념을 이용해 작업을 분산처리
- GCD/Operation을 사용해 시스템에서 알아서 쓰레드 숫자를 관리
(직접 쓰레드를 생성하는 것은 하드웨어나 일의 부하와 같은 시스템에 대한 지식없이 사용하면, 오히려 앱이 느려질 수 있다)
- 쓰레드보다 더 높은 레벨/차원에서 일을 한다고 볼 수 있다
- 쉽게 다른 쓰레드에서 오래걸리는 작업들이 비동기적으로 동작하도록 만들어준다
(보통 오래걸리는 작업은 **네트워크** 와 관련되어 있다)
(어떤 API ex Kingfisher와 같이 내부적으로 다른 쓰레드에서 비동기적으로 실행되도록 설계되어 있다. 중복해서 처리하지 않도록 조심)

### 2-1. 그렇다면 어떻게 대기열로 작업을 보낼까?
```DispatchQueue.global().async{ 작업의 한 단위(task) } ```  
Dispatch(보내다)Qeueue(대기행렬) = 큐에 보낼거야!  
DispatchQueue.global() = 글로벌큐에  
DispatchQueue.global().async = 비동기적으로!

**작업의 한 단위는 내부적으로 순차적으로 동작하게 된다**  

### 2-2. GCD VS Operation
#### GCD
- 간단한 일(커뮤니케이션의 양)
- 함수를 사용하는 작업(메서드 위주)

#### Operation
- 복잡한 일(커뮤니케이션의 양)
- 데이터와 기능을 캡슐화한 객체
- GCD 내용을 기반으로 만들어진 여러가지 기능(**취소 / 순간지정 / 일시중지(상태추적)** )을 추가한 개념

## 3. Synchronous(동기) VS Asynchronous(비동기)
### Asynchronous(비동기)
- 작업을 처리하는 시간 자체가 오래걸린다고 가정한다면, 일을 시작하고 **"안 기다린다"**  
- 즉, task의 완료여부와 상관없이 메인쓰레드가 다른 일 처리를 시작할 수 있다는 뜻이다.  
- (정리): 작업을 다른 쓰레드에서 하도록 시킨 후, 그 작업이 끝나길 안기다리고 다음일을 진행한다.

```DispatchQueue.global().async{ 작업의 한 단위(task) } ```  
: Gobal Queue로 보낸 작업의 완료를 기다리지 않을거야!

### Synchronous(동기)
- 작업을 시작시키고, 작업이 끝날 때까지 block하고 **"기다린다"** 
- (정리): 작업을 다른 쓰레드에서 하도록 시킨 후, 그 다음 작업이 끝나길 기다렸다가 다음일을 진행한다.  
```DispatchQueue.global().sync{ 작업의 한 단위(task) } ```  
: Global Queue로 보낸 작업을 동기적으로 기다릴거야!

### 이러한 "비동기"라는 개념이 일반적으로 필요한 이유는?
대부분은 서버와의 통신 때문.(네트워크와 관련된 작업들은 내부적으로 비동기적으로 구현)
ex) URLSession 자체 또한 이미 내부적으로 비동기적으로 실행된다

## 4. [큐의 2가지 특성] Serial(직렬) VS Concurrent(동시)
### Serial Queue(직렬 큐)
- 보통 메인에서 분산처리 시킨 작업을 **"다른 한 개의 쓰레드에서"** 처리하는 큐
- 순서가 중요한 작업을 처리할 때 사용

### Concurrent Queue(동시 큐)
- 보통 메인에서 분산처리 시킨 작업을 **"다른 여러개의 쓰레드에서"** 처리하는 큐
- 물론 몇개의 쓰레드로 분산할지는 시스템(OS)이 알아서 결정. 다만 여러개의 쓰레드로 분산 처리를 한다.
- 각자 **독립적이지만 유사한(중요도나 작업의 성격) 여러 개의 작업** 을 처리할 때 사용

